use System.Security.Cryptography

use Cobra.Compiler

use MonoDevelop.Ide.TypeSystem
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Projects

use ICSharpCode.NRefactory
use ICSharpCode.NRefactory.TypeSystem

use MonoDevelop.CobraBinding

namespace MonoDevelop.CobraBinding.TypeSystem

class Parser implements ITypeSystemParser, IFoldingParser
	"""
	The type system parser provides a ParsedDocument required for adding 
	information to the type system service to make the file contents available 
	for type lookup (code completion, resolving etc.).
	
	This parser also provides folds and underlines syntax errors.
	"""
	
	const TYPICAL_LINE_COUNT = 512 # 4 kB
		
	var _tabsToSpaces = false
	var _indentToken = "\t"
	var _md5Computer = MD5.create

	# these dictionaries are keyed by filename
	shared
		var _md5s = Dictionary<of String, String>()
		var _moduleCache = Dictionary<of String, CobraModule>()
		var _errorCache = Dictionary<of String, List<of dynamic>>()


	def _getCachedModule(fileName as String, md5s as Dictionary<of String, String>) as CobraModule?
		"""
		Returns the CobraModule with the given fileName from the cache or nil
		if the module is not in the cache.
		
		IMPORTANT! Do not include tests in compilation otherwise calls to this
		method will clear the cache.
		"""
		test miss
			p = Parser()
			p._clearCache
			md5s = Dictionary<of String, String>()
			assert p._getCachedModule('test.cobra', md5s) == nil

			md5s['test.cobra'] = p._getMd5Hash('hello')
			assert p._getCachedModule('test.cobra', md5s) == nil

		test hit
			p = Parser()
			p._clearCache
			hash = p._getMd5Hash('hello')
			Parser._md5s['test.cobra'] = hash
			t = Token('test.cobra', 1, 1, 1, 'hello', 'hello', nil)
			ns = NameSpace(t, 'TestingNameSpace')
			Parser._moduleCache['test.cobra'] = CobraModule('test.cobra', 0, "testing", ns)

			md5s = Dictionary<of String, String>()
			md5s['test.cobra'] = hash

			module = p._getCachedModule('test.cobra', md5s)
			assert module <> nil
			assert module is Parser._moduleCache['test.cobra']

		body
			for key, hash in md5s
				if not _md5s.containsKey(key) or _md5s[key] <> hash
					# one or more of the source files has changed
					return nil

			if not _moduleCache.containsKey(fileName)
				return nil

			return _moduleCache[fileName]
		

	def _getMd5Hash(fileContents as String) as String
		"""
		Returns String representation of the  MD5 hash code for the given
		input string.

		See http://msdn.microsoft.com/en-us/library/system.security.cryptography.md5.aspx
		"""
		test
			input = "class MD5Test"
			p = Parser()
			assert p._getMd5Hash(input) == "d8b8c1c757769993506767adab256d57"
		body
			hash = _md5Computer.computeHash(Encoding.utf8.getBytes(fileContents))

			sb = StringBuilder()
			for byte in hash
				sb.append(byte.toString("x2"))

			return sb.toString

	
	def _clearCache
		_moduleCache.clear
		_md5s.clear
		_errorCache.clear
	
	
	def parse(storeAst as bool, fileName as String, content as TextReader,
				project as MonoDevelop.Projects.Project?) as ParsedDocument
		"""
		implements ITypeSystemParser.parse
		
		Generates folds and parses the specified file using the Cobra Parser.
		Stores the resultant AST in the ParsedDocument when storeAst is true.
		"""
		module as CobraModule? = nil
		visitor as MonoDevelop.CobraBinding.TypeSystem.Visitor? = nil
		
		source = content.readToEnd
		if source == nil, source = ""

		md5s = Dictionary<of String, String>()
		md5s[fileName] = _getMd5Hash(source to !)

		sourceMap = Dictionary<of String, String>()
		sourceMap[fileName] = source to !
		
		refs = List<of String>()

		if project <> nil
			proj = project to DotNetProject #TODO to CobraProject

			# we need to include the paths to any referenced assemblies
			refs.addRange(proj.getReferencedAssemblies(ConfigurationSelector.default))
			
			# to generate a full AST, we need all the Cobra source files in this project
			for projFile in proj.files
				
				path = projFile.filePath.toString
				
				if path <> fileName
					if path.endsWith(CobraLanguageBinding.sourceFileExtension)
						if projFile.buildAction == BuildAction.compile
							
							reader = StreamReader(path)
							otherSource = reader.readToEnd
							if otherSource == nil, otherSource = ""
							md5s[path] = _getMd5Hash(otherSource to !)
							sourceMap[path] = otherSource to !

		compilerResults = List<of dynamic>(proj.files.count)
		
		lock _moduleCache # seems kind of brittle to lock directly on the dictionary but...meh
			module = _getCachedModule(fileName, md5s)
			if module <> nil
				#cache hit
				trace "cache hit for [fileName]"
				if _errorCache.containsKey(module.fileName)
					compilerResults.addRange(_errorCache[module.fileName])
				
			else
				# cache miss
				trace "cache miss for [fileName]"
				_clearCache

				# parse the source files and bind the AST nodes to their types
				compilerResults.addRange(CompilerManager.instance.parseAndBind(sourceMap, refs))
				
				for entry in compilerResults
					if entry inherits CobraModule
						# cache this module for next time
						_moduleCache[entry.fileName] = entry
						_md5s[entry.fileName] = md5s[entry.fileName]

						if entry.fileName == fileName
							# this was the requested module
							module = entry
					else
						# this entry is an error
						if not _errorCache.containsKey(entry.fileName)
							_errorCache[entry.fileName] = List<of dynamic>()
						else
							_errorCache[entry.fileName].add(entry)

		if module <> nil
			# create type and region maps
			visitor = MonoDevelop.CobraBinding.TypeSystem.Visitor()
			visitor.visit(module)
		
		# add folds
		parsedDoc = .parse(fileName, source) to ParsedCobraDocument

		if visitor <> nil
			parsedDoc.regionMap = visitor.regionMap
		
		# underline errors
		for err in compilerResults
			if not err inherits Module
				if err inherits ParserException and err.fileName == fileName
					parsedDoc.add(Error(ErrorType.Error, err.message, err.lineNum, err.colNum - 1))
					trace err.message
				else if err inherits SourceException and err.fileName == fileName
					parsedDoc.add(Error(ErrorType.Error, err.message, err.lineNum, err.colNum))
					trace err.message + " " + err.lineNum.toString + " " + err.colNum.toString
				else
					trace err.toString
		
		if storeAst
			parsedDoc.ast = module

		return parsedDoc
		
	def parse(fileName as String, content as String) as ParsedDocument
		"""
		implements IFoldingParser.parse
		
		Parse the specified file to generate folds.
		"""
		parsedDoc = ParsedCobraDocument(fileName, content)
		
		reader = StringReader(content)
		folds = List<of FoldingRegion>()
		_addFolds(_getLineInformation(reader), folds)
		
		parsedDoc.add(folds)

		return parsedDoc
	
	
	def _getLineInformation(reader as StringReader) as List<of LineInformation>
		lines = List<of String>(.TYPICAL_LINE_COUNT)
		
		line = reader.readLine
		while line <> nil
			lines.add(line)
			line = reader.readLine
			
		if lines.count > 0
			return _getLineInformation(lines)
			
		return List<of LineInformation>()
		
	def _getLineInformation(lines as List<of String>) as List<of LineInformation>
		"""
		Create a list of LineInformation objects that make it easier to 
		create folding regions.
		"""
		require
			lines.count > 0
		ensure
			result.count == lines.count
		test
			source = List<of String>()
			source.add("use Foo.Namespace") # line 0
			source.add("")
			source.add("namespace Bar.Namespace")
			source.add("\tclass SomeClass")
			source.add("\t\t'''")
			source.add("\t\tDocstring text") # line 5
			source.add("\t\t'''")
			source.add("")
			source.add("\t\tdef aMethod")
			source.add("/#")
			source.add("\ta comment") # line 10
			source.add("\t\t#/")
			source.add("\t\t\t")
			source.add("\t\t\tprint 'hello world!'")
			source.add("")
			source.add("")
			
			parser = Parser()
			infoList = parser._getLineInformation(source)
						
			assert infoList[0].opensComment == false
			assert infoList[0].closesComment == false
			assert infoList[0].opensDocString == false
			assert infoList[0].closesDocString == false
			assert infoList[0].isBlank == false
									
			assert infoList[1].opensComment == false
			assert infoList[1].closesComment == false
			assert infoList[1].opensDocString == false
			assert infoList[1].closesDocString == false
			assert infoList[1].isBlank == true #
						
			assert infoList[4].opensComment == false
			assert infoList[4].closesComment == false
			assert infoList[4].opensDocString == true #
			assert infoList[4].closesDocString == false
			assert infoList[4].isBlank == false
						
			assert infoList[5].opensComment == false
			assert infoList[5].closesComment == false
			assert infoList[5].opensDocString == false
			assert infoList[5].closesDocString == false
			assert infoList[5].isBlank == false
						
			assert infoList[6].opensComment == false
			assert infoList[6].closesComment == false
			assert infoList[6].opensDocString == false
			assert infoList[6].closesDocString == true #
			assert infoList[6].isBlank == false
			
			assert infoList[9].opensComment == true #
			assert infoList[9].closesComment == false
			assert infoList[9].opensDocString == false
			assert infoList[9].closesDocString == false
			assert infoList[9].isBlank == false
			
			assert infoList[10].opensComment == false
			assert infoList[10].closesComment == false
			assert infoList[10].opensDocString == false
			assert infoList[10].closesDocString == false
			assert infoList[10].isBlank == false
			
			assert infoList[11].opensComment == false
			assert infoList[11].closesComment == true #
			assert infoList[11].opensDocString == false
			assert infoList[11].closesDocString == false
			assert infoList[11].isBlank == false
			
			assert infoList[12].opensComment == false
			assert infoList[12].closesComment == false
			assert infoList[12].opensDocString == false
			assert infoList[12].closesDocString == false
			assert infoList[12].isBlank == true #
		body
			info as LineInformation? = nil
			inComment = false
			inDocString = false
			docStringTag as String? = nil
			infoList = List<of LineInformation>(lines.count)
	
			for line in lines
	
				info = LineInformation(line, inComment, inDocString, docStringTag, info)
	
				if not inComment and info.opensComment
					inComment = true
				else if inComment and info.closesComment
					inComment = false
	
				if not inDocString and info.opensDocString
					inDocString = true
					docStringTag = info.docStringTag
				else if inDocString and info.closesDocString
					inDocString = false
					docStringTag = nil
	
				infoList.add(info)
				
			return infoList

	sig ClosesDelimitedBlock(info as LineInformation) as bool

	def _addFolds(infoList as List<of LineInformation>, folds as List<of FoldingRegion>)
		"""
		Adds folds to the given list of folds using the given list of line information.
		"""
		test
			source = List<of String>()
			source.add("use Foo.Namespace")
			source.add("")
			source.add("namespace Bar.Namespace")
			source.add("\tclass SomeClass")
			source.add("\t\t'''")
			source.add("\t\tDocstring text")
			source.add("\t\t'''")
			source.add("")
			source.add("\t\tdef aMethod")
			source.add("/#")
			source.add("\ta comment")
			source.add("\t\t#/")
			source.add("\t\t\t")
			source.add("\t\t\tprint 'hello world!'")
			source.add("")
			source.add("")
			
			parser = Parser()
			infoList = parser._getLineInformation(source)
			folds = List<of FoldingRegion>()
			parser._addFolds(infoList, folds)
			
			assert folds.count == 5
			
			commentBlockCount = 0
			for f in folds
				if f.type == FoldType.Comment
					commentBlockCount += 1
				else
					assert f.region.endLine == 14
					
			assert commentBlockCount == 2

		test docStrings
			source = List<of String>()
			source.add("'''")
			source.add("Program docstring")
			source.add("'''")
			source.add("interface SomeInterface")
			source.add("\t'''")
			source.add("\tDocstring text for interface")
			source.add("\t'''")
			source.add("")
			source.add("\tget aProperty")
			source.add("\t\t'''")
			source.add("\t\tProperty Docstring")
			source.add("\t\t'''")
			
			parser = Parser()
			infoList = parser._getLineInformation(source)
			folds = List<of FoldingRegion>()
			parser._addFolds(infoList, folds)
			
			assert folds.count == 5
			
			commentBlockCount = 0
			for f in folds
				if f.type == FoldType.Comment
					commentBlockCount += 1
					
			assert commentBlockCount == 3
		body
			if infoList.count < 2
				# not enough lines to create a fold
				return
	
			commentCloser as ClosesDelimitedBlock = do(i as LineInformation)
				return i.opensComment
	
			docStringCloser as ClosesDelimitedBlock = do(i as LineInformation)
				return i.opensDocString
	
			lineNumber = infoList.count
			curr as LineInformation? = infoList[lineNumber - 1]
	
			endStack = Stack<of TextLocation>()
			levelStack = Stack<of int>()
	
			# go through the list backwards creating folds as we go
			while curr <> nil
	
				closer as ClosesDelimitedBlock? = nil
	
				# skip blank lines
				while curr.isBlank
					curr = curr.previous
					if curr == nil
						return
					lineNumber -= 1
	
				# handle comment blocks and doc strings
				if curr.closesComment
					closer = commentCloser
				else if curr.closesDocString
					closer = docStringCloser
	
				if closer <> nil
					endLocation = TextLocation(lineNumber, curr.line.length + 1)
					
					if closer == docStringCloser
					
						level = _getIndentLevel(curr.line)
						if level > 0
							if levelStack.count == 0 or (levelStack.count > 0 and levelStack.peek < level)
								/# We need to make sure the doc string
								closes with its containing block #/
								levelStack.push(level)
								endStack.push(endLocation)
	
					# we won't have a line that closes a delimited block without one that opens it
					blockText = curr to !
					while not closer(blockText)
						blockText = blockText.previous to !
						lineNumber -= 1
	
					curr = blockText
					startLocation = TextLocation(lineNumber, curr.line.length + 2)
					folds.add(FoldingRegion(DomRegion(startLocation, endLocation), FoldType.Comment))
					curr = curr.previous
					lineNumber -= 1
					continue
		
				# handle indent blocks (ignore commented lines)
				if not curr.line.trimStart.startsWith("#")
				
					level = _getIndentLevel(curr.line)
					
					# should we close any regions?
					while levelStack.count > 0 and levelStack.peek > level
						levelStack.pop
						endLocation = endStack.pop
						startLocation = TextLocation(lineNumber, curr.line.length + 2)
						folds.add(FoldingRegion(DomRegion(startLocation, endLocation), FoldType.Undefined))
					
					# should we open any regions?
					if levelStack.count == 0
						first = 0
					else if level > levelStack.peek
						first = levelStack.peek
					else
						# makes the following loop do nothing
						first = level + 2
																	
					for l in first : level + 1
						levelStack.push(l)
						endStack.push(TextLocation(lineNumber, curr.line.length + 1))
	
				curr = curr.previous
				lineNumber -= 1


	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		require
			line.trim.length > 0
		ensure
			result >= 0
		test
			assert Parser()._getIndentLevel("print 'hello'") == 0
			assert Parser()._getIndentLevel("\tprint 'hello'") == 1
			assert Parser()._getIndentLevel("\t\tprint 'hello'") == 2
		body
			return (line.length - line.trimStart.length) // _indentToken.length

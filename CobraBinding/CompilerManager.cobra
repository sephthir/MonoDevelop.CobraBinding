use Cobra.Compiler

namespace MonoDevelop.CobraBinding

class CompilerManager
	"""
	This class provides serial access to the Cobra compiler. If multiple
	threads attempt to invoke conflicting methods, the thread will be
	blocked until the compiler is available.  This class utilizes a single
	lock to avoid deadlocks for conflicting resources.
	"""
	test
		cm1 = CompilerManager.instance
		cm2 = CompilerManager.instance
		assert cm1 is cm2

	class CustomBindImplementationPhase inherits BindImplementationPhase is protected
		"""
		Bind the AST nodes inside methods and properties but only for a single file.
		"""
		var _fileName as String
		
		cue init(c as Compiler, fileToBind as String)
			base.init(c)
			_fileName = fileToBind
		
		get description as String is override
			return 'Binding implementation for [_fileName]'
		
		def innerRun is override
			c = .compiler
			for mod in c.modules.clone
				if mod.fileName == _fileName
					c.curModule = mod
					try
						mod.bindImp
					catch ce as SourceException
						c.recordError(ce)
					break
			
			# this will be used in CobraModuleVisitor when creating the symbol table
			key = CobraLanguageBinding.AddOnKeys.globalNameSpace
			boundAst = mod to CobraModule
			boundAst.topNameSpace.addOnValues[key] = c.globalNS
	
	shared
		var _instance as CompilerManager? = nil
	
		get instance as CompilerManager
			if _instance == nil
				_instance = CompilerManager()
			return _instance to !
			
		# only the thread holding the conch can use the compiler
		var _theConch = Object()
		
		# the compiler phases we want to run for all files
		var _phaseTypes = @[
			BindRunTimeLibraryPhase,
			ReadLibrariesPhase,
			ParsePhase,
			BindUsePhase,
			BindInheritancePhase,
			BindInterfacePhase,
			ComputeMatchingBaseMembersPhase,
		] # .CustomBindImplementationPhase gets added manually later

	# Callers have to use CompilerManager.instance instead
	cue init is protected
		base.init
	
	
	def __createCompiler as Compiler
		"""
		Returns a fresh instance of the compiler.
		
		Should only be called if we have _theConch.
		"""
		compiler = Compiler(0) # verbosity = 0
		
		options = OptionValues()
		options.add("compile", true)
		options.add("back-end", "clr")
		options.add("turbo", true)
		options.add("number", "decimal")
		
		compiler.options = options
		compiler.initBackEnd
		
		# Set some shared information which gets reset everytime we instantiate a compiler.
		Node.setCompiler(compiler)
		Node.typeProvider = compiler
		
		return compiler
	
	
	def parseAndBind(sourceMap as Dictionary<of String, String>, fileToBind as String) as TypeSystem.ParsedCobraDocument
		"""
		Runs select phases of the Cobra compiler.
		
		The sourceMap is a dictionary whose values are source file contents keyed
		by filename.
		"""
		test validFiles
			# Valid files produce fully bound ASTs without any errors.
			
			cm = CompilerManager.instance
			testData = .readTestData("no_errors")
			astCount = 0

			for filePath, code in testData
				# process each file individually
				doc = cm.parseAndBind({filePath: code}, filePath)
				assert doc.errors.count == 0
				
				# validate the AST
				ast = doc.getAst<of CobraModule>
				astCount += 1
				
				assert ast.didBindImp
				key = CobraLanguageBinding.AddOnKeys.globalNameSpace
				assert ast.topNameSpace.addOnValues.containsKey(key)

				name =  FileInfo(filePath).name
				branch name
					on "Point.cobra"
						pointClass = ast.topNameSpace.memberForName("Point") to Class
						assert pointClass.memberForName("toString")
						assert pointClass.memberForName("getHashCode")
						assert pointClass.name == "Point"
						assert pointClass.typeForReceiver is pointClass
						assert pointClass.testMethods.count == 1
						p = pointClass.memberForName("x")
						assert p.getType == Property
						assert p.typeForReceiver inherits IntType
						m = pointClass.memberForName("movedBy")
						assert m.getType == Method
						assert m.typeForReceiver is pointClass

					on "Shapes.cobra"
						assert ast.topNameSpace.memberForName("Shape")
						assert ast.topNameSpace.memberForName("Rectangle")
						assert ast.topNameSpace.memberForName("Circle")
						assert ast.topNameSpace.memberForName("Program")

					on "FractalBenchmark.cobra"
						prog = ast.topNameSpace.memberForName("Program") to Class
						assert prog.memberForName("bailOut")
						assert prog.memberForName("maxIterations")
						assert prog.memberForName("mandelbrot")
						assert prog.memberForName("calc")
						assert prog.memberForName("main")
						
					on "ForCompletionTesting.cobra"
						# this gets tested by the CobraCompletionTextEditorExtension class
						pass
						
					on "ForCobraModuleVisitorTesting1.cobra" _
					or "ForCobraModuleVisitorTesting2.cobra"
						# these get tested by the CobraModuleVisitor class
						pass
					
					on "ForTooltipTesting.cobra"
						# this gets tested by the TooltipProvider class
						pass

					else
						# unhandled file, a case should be added for it
						print "******* You need to add a test case for [name]!"
						assert false

			assert testData.count == astCount
				
		test parseErrors
			# Files with parse errors do not provide an AST.
			
			cm = CompilerManager.instance
			testData = .readTestData("parser_errors")
			errorCount = 0

			for filePath, code in testData
				# process each file individually
				doc = cm.parseAndBind({filePath: code}, filePath)
				assert doc.ast == nil
				name =  FileInfo(filePath).name
				assert doc.errors.count == 1
				err = doc.errors[0]
				errorCount += 1
				branch name
					on "ExpectingEol.cobra"
						assert err.region.beginLine == 3
						assert err.region.beginColumn == 0
						assert err.message == 'Expecting EOL, but got "var" instead.'

					on "ExpectingExpression.cobra"
						assert err.region.beginLine == 5
						assert err.region.beginColumn == 11
						assert err.message == "Expecting an expression."

					on "ExpectingIndent.cobra"
						assert err.region.beginLine == 3
						assert err.region.beginColumn == 14
						assert err.message == 'Expecting INDENT, but got "DEDENT" instead.'
						
					on "MissingMethodBody.cobra"
						assert err.region.beginLine == 2
						assert err.region.beginColumn == 15
						assert err.message == 'Missing method body for "someMethod".'
						
					on "UnexpectedIndent.cobra"
						assert err.region.beginLine == 2
						assert err.region.beginColumn == 0
						assert err.message == 'Unexpected indent.'
						
					on "MixedTabsAndSpaces.cobra"
						assert err.region.beginLine == 2
						assert err.region.beginColumn == 0
						assert err.message == ns'Cannot mix tabs and spaces in indentation. [TAB][SPACE][SPACE][SPACE][SPACE]...'

					else
						# unhandled file, a case should be added for it
						print "******* You need to add a test case for [name]!"
						assert false

			assert testData.count == errorCount

		test bindErrors
			# Files with binding errors still provide an AST.
			
			cm = CompilerManager.instance
			testData = .readTestData("binding_errors")
			astCount = errorCount = 0

			for filePath, code in testData
				# process each file individually
				doc = cm.parseAndBind({filePath: code}, filePath)
				ast = doc.getAst<of CobraModule>
				astCount += 1
				name = FileInfo(ast.fileName).name
				assert doc.errors.count == 1
				err = doc.errors[0]
				errorCount += 1
				branch name
					on "CannotFindType.cobra"
						assert err.region.beginLine == 3
						assert err.region.beginColumn == 8
						assert err.message == 'Cannot find "Fake".'
						
						c = ast.topNameSpace.memberForName("CannotFindType") to Class
						assert c.memberForName("method")
						
					on "NilError.cobra"
						assert err.region.beginLine == 5
						assert err.region.beginColumn == 2
						assert err.message == 'Cannot return String? because "method" is declared to return a String.'
						
						c = ast.topNameSpace.memberForName("NilError") to Class
						assert c.memberForName("a")
						assert c.memberForName("method")
						
					on "TypeMismatch.cobra"
						assert err.region.beginLine == 4
						assert err.region.beginColumn == 14
						assert err.message == 'Incompatible types. Cannot assign value of type int on the right to String on the left.'

						c = ast.topNameSpace.memberForName("TypeMismatch") to Class
						assert c.memberForName("method")
					else
						# unhandled file, a case should be added for it
						print "******* You need to add a test case for [name]!"
						assert false
					
			assert testData.count == astCount == errorCount

		body
			return .parseAndBind(sourceMap, List<of String>(), fileToBind)
	
	
	def parseAndBind(sourceMap as Dictionary<of String, String>, refs as List<of String>,
			fileToBind as String) as TypeSystem.ParsedCobraDocument
		"""
		Runs select phases of the Cobra compiler.
		
		The sourceMap is a dictionary whose values are source file contents keyed
		by filename.
		"""
		if sourceMap.count == 0
			# nothing to do
			return TypeSystem.ParsedCobraDocument(fileToBind, "")
			
		params = CompileParams()
		for fileName, sourceCode in sourceMap
			params.files.add(FileSpec(fileName, sourceCode))
		
		lock _theConch
			compiler = __createCompiler
			
			compiler.options['reference'] = refs
			for phaseType in _phaseTypes
				params.phases.add(phaseType(compiler))
			params.phases.add(.CustomBindImplementationPhase(compiler, fileToBind))
			
			try
				compiler.compile(params)
			catch StopCompilation
				# source files with errors will throw these
				# but we just ignore them
				pass
			catch ex as Exception
				print "The compiler crashed trying to compile [fileToBind]"
				trace ex
			
			doc = TypeSystem.ParsedCobraDocument(fileToBind, sourceMap[fileToBind])
			doc.add(compiler.errors)

			for module in compiler.modules
				if module.fileName == fileToBind
					doc.add(module to CobraModule)
			
		return doc


	shared
		def readTestData(folder as String) as Dictionary<of String, String>
			"""
			This function is only for supporting test methods.  The 'folder'
			parameter should exist under '../../test_data' which is relative
			to the location of the 'scripts/refs' path under 'CobraBinding'.
			"""
			s = Path.directorySeparatorChar
			testDir = "..[s]..[s]test_data[s][folder]"
			assert Directory.exists(testDir)

			sourceMap = Dictionary<of String, String>()

			files = Directory.getFiles(testDir)
			for filePath in files
				reader = StreamReader(filePath)
				code = reader.readToEnd ? ""

				sourceMap[filePath] = code

			return sourceMap

use Cobra.Compiler

use MonoDevelop.CobraBinding.TypeSystem

use MonoDevelop.Core
use MonoDevelop.Projects
use MonoDevelop.Ide.Gui.Content
use MonoDevelop.Ide.CodeCompletion
use MonoDevelop.Ide.TypeSystem

use ICSharpCode.NRefactory.Completion
use ICSharpCode.NRefactory.TypeSystem

namespace MonoDevelop.CobraBinding.Completion

class CobraCompletionTextEditorExtension inherits CompletionTextEditorExtension

	shared
		/#
		This is the previous map generated by the TypeSystem.Visitor.
		It's used when the current document has parser errors.
		The containing dictionary is keyed by the document filename.
		#/
		var __prevRegionMap = Dictionary<of String, Dictionary<of ISyntaxNode, DomRegion>>()

		# the various icons that show up next to completion entries
		var iconKeyword = IconId("md-keyword")
		var iconClass = IconId("md-class")
		var iconField = IconId("md-field")
		var iconLiteral = IconId("md-literal")
		var iconMethod = IconId("md-method")
		var iconDelegate = IconId("md-delegate")
		var iconStruct = IconId("md-struct")
		var iconEvent = IconId("md-event")
		var iconProperty = IconId("md-property")
		var iconInterface = IconId("md-interface")
		var iconEnum = IconId("md-enum")
		var iconNamespace = IconId("md-name-space")
		
		var keywordsTopLevel = @[
			"use",
			"namespace",
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
			"extend",
			"adds",
			"inherits",
			"implements",
			"has",
			"is",
		]
		
		var keywordsFollowingIs = @[
			"public",
			"protected",
			"private",
			"internal",
			"partial",
			"extern",
			"abstract",
			"override",
		]
		
		var keywordsInBox = @[
			"is",
			"def",
			"var",
			"test",
			"invariant",
			"cue init",
			"var",
			"as",
			"def",
			"pro",
			"get",
			"set",
			
			"class",
			"interface",
			"struct",
			"mixin",
			"enum",
			"sig",
		]
		
		var keywordsInMethod = @[
			"require",
			"ensure",
			"test",
			"body",
			
			"print",
			"lock",
			"using",
			"try",
			"catch",
			"finally",
			"throw",
			"assert",
			"trace",
			"if",
			"and",
			"or",
			"not",
			"in",
			"else",
			"branch",
			"on",
			"for",
			"while",
			"post",
			"return",
		]
		
		var keywordsCobraTypes = @[
			"bool",
			"char",
			"int",
			"uint",
			"float",
			"decimal",
			"number",
			"dynamic"
		]
		
		var charsToIgnore = @[
			c',',
			c')',
			c'[',
			c']',
			c'"',
			c"'",
		]
		#' TODO: handle the case above in CobraSyntaMode.xml
		
	def handleCodeCompletion(context as CodeCompletionContext?, completionChar as char,
							triggerWordLength as inout int) as ICompletionDataList? is override
		"""
		This method is called indirectly by .keyPress or when the user hits Ctrl+Space.
		"""
		
		if completionChar in .charsToIgnore
			return nil
		
		if completionChar == c'('
			#TODO handle parameter completion
			return nil
		
		/#
		.document is a MonoDevelop.Ide.Gui.Document
		.document.editor.document is a Mono.TextEditor.Document
		.document.parsedDocument is a MonoDevelop.CobraBinding.TypeSystem.ParsedCobraDocument
		#/
		if context == nil or .document == nil or .document.parsedDocument == nil
			# not enough information to be able to provide completion results
			return nil
			
		line = context.triggerLine
		col = context.triggerLineOffset
		
		textDoc = .document.editor.document
		lineText = textDoc.getLineText(line)
		if String.isNullOrEmpty(lineText), lineText = ""
		
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
					
		if _isInsideComment(line, col, lineText to !)
			return nil
		
		# get code regions from last valid parse tree
		regionMap as Dictionary<of ISyntaxNode, DomRegion>? = nil
		if parsedDoc.regionMap <> nil
			regionMap = parsedDoc.regionMap
			__prevRegionMap[parsedDoc.fileName] = regionMap to !
		else if __prevRegionMap.containsKey(parsedDoc.fileName)
			regionMap = __prevRegionMap[parsedDoc.fileName]
		
		if regionMap == nil
			# not enough information to provide completion
			return nil
			
		
		# extend code regions to include blank lines and generate a reverse map
		codeRegions = List<of DomRegion>()
		nodeMap = Dictionary<of DomRegion, ISyntaxNode>()
		for node, region in regionMap to !
			extendedRegion = _extendRegion(region)
			codeRegions.add(extendedRegion)
			nodeMap[extendedRegion] = node
			
		for extendedRegion, node in nodeMap
			regionMap[node] = extendedRegion
		
		# DEBUGGING
		/#
		for node, region in regionMap to !
			trace node.getType.toString
			trace region.toString
		#/
		__prevRegionMap[parsedDoc.fileName] = regionMap to !
				
		if completionChar <> c' '
			# do this so that the letter just typed is considered part of the word to complete
			while col > 0 and lineText[col - 1] not in @[c'\t', c' ']
				triggerWordLength += 1
				col -= 1
			
		if col < 0
			# this can happen on manual triggering of code completion via Ctrl+Space from the start of a blank line
			col = 0
		
		containingRegions = .getContainingRegions(line, col, codeRegions)
		completionData = CompletionDataList()
		preceedingText = lineText.substring(0, .document.editor.caret.column - 1)
		
		if completionChar == c'.'
			# member completion
			
			# don't include the dot in the trigger word length
			triggerWordLength -= 1
			
			id = _getIdFromText(preceedingText)
			if true
				# return fields and methods in the context of the current class
				for region in containingRegions
					node = nodeMap[region]
					if node inherits Class
						completionData.addRange(_getClassMemberCompletionData(node))
				return completionData
			else
				# return fields and methods for the corresponding node
				try
					node = _getNodeFromId(id)
					if node inherits Class
						completionData.addRange(_getClassMemberCompletionData(node))
					return completionData
				catch
					# not a valid identifier
					return nil
		
		# return unique completion data entries
		dataSet = HashSet<of String>()
		uniqueData = List<of ICompletionData>()
				
		for region in containingRegions
			for d in _getCompletionData(region, preceedingText, "TODO", nodeMap)
				if dataSet.add(d.toString)
					uniqueData.add(d)
		
		completionData.addRange(uniqueData)
		
		if completionData.count <> 0
			return completionData
		else
			return nil
		

	def handleParameterCompletion(context as CodeCompletionContext?, completionChar as char) _
		as IParameterDataProvider? is override

		return nil

		
	def _isInsideComment(line as int, col as int, lineText as String) as bool
		"""
		Returns true if the cursor is inside a comment region.
		"""
		if line < 1, line = 1
		if col < 0, col = 0
		
		if lineText.trimStart.startsWith("#")
			#TODO: Detect cases when inside a string or inside trailing comments
			return true
		
		parsedDoc = .document.parsedDocument to ParsedCobraDocument
		
		for fold in parsedDoc.foldings
			if fold.type == FoldType.Comment and fold.region.isInside(line, col)
				return true
				
		return false
		

	def getContainingRegions(line as int, col as int, regions as DomRegion*) as List<of DomRegion>
		"""
		Returns a list of document regions from the given region stream that contain the 
		given document location.
		"""
		ensure # we'll never return more regions than what was given
			result.count <= List<of DomRegion>(regions).count
		test
			rs = List<of DomRegion>()
			rs.add(DomRegion(1, 1, 10, 120))
			rs.add(DomRegion(1, 1, 5, 120))
			rs.add(DomRegion(6, 1, 10, 120))
			rs.add(DomRegion(11, 1, 15, 120))
			rs.add(DomRegion(12,1, 14, 120))

			complExt = CobraCompletionTextEditorExtension()
			assert complExt.getContainingRegions(1, 1, rs).count == 2
			assert complExt.getContainingRegions(2, 1, rs).count == 2
			assert complExt.getContainingRegions(5, 80, rs).count == 2
			assert complExt.getContainingRegions(6, 10, rs).count == 2
			assert complExt.getContainingRegions(11, 1, rs).count == 1
			assert complExt.getContainingRegions(13, 1, rs).count == 2
			assert complExt.getContainingRegions(15, 20, rs).count == 1
			assert complExt.getContainingRegions(16, 1, rs).count == 0
		body
			containingRegions = List<of DomRegion>()
			for r in regions
				if r.isInside(line, col)
					containingRegions.add(r)

			return containingRegions
			
			
	def _extendRegion(region as DomRegion) as DomRegion
		"""
		Returns a copy of the given region but extends the last line
		to include all blank lines that immediately follow it.
		
		The ending point will be the 0th column of the first non-blank
		line.
		"""
		require
			.document.editor.document <> nil
			region.beginLine > 0
		ensure
			result.beginLine == region.beginLine
			result.endLine >= region.endLine
		body
			textDoc = .document.editor.document
			fromLine = region.endLine + 1
			untilLine = textDoc.lineCount + 1
			
			for line in fromLine:untilLine
				text = textDoc.getLineText(line)
				if text <> nil and text.trim.length > 0
					break
			
			extendedRegion = DomRegion(region.fileName, _
			region.beginLine, region.beginColumn, _
			line, 0)
			
			return extendedRegion

	def _getIndentLevel(line as String) as int
		"""
		Returns the number of indents for the given line.
		"""
		# Crap!  This function already exists in Parser.  Shouldn't be repeated here.
		return line.length - line.trimStart.length

	def _getIdFromText(text as String) as String
		"""
		Given arbitrary text, returns the last identifier
		"""
		#TODO
		id = text.trim
		print id
		return ""
		
	def _getNodeFromId(id as String) as ISyntaxNode
		"""
		Given a valid identifier, returns the corresponding syntax node in the AST.
		
		Throws an ArgumentException if no node is found.
		"""
		#TODO
		throw ArgumentException()
		

	def _getTopLevelCompletionData(preceedingText as String, currText as String) as ICompletionDataList
		"""
		Returns completion data when we are in the context of a namespace and can
		declare classes, interfaces, etc.
		
		TODO: Use RegEx's instead of crossing our fingers and using string literals
		"""
		
		dataList = CompletionDataList()
		if preceedingText.endsWith("use ")
			# provide namespaces from explicit references
			dataList.addRange(_getNamespacesFromProjectRefs)
			
		else if preceedingText.endsWith(" is ")
			for kw in .keywordsFollowingIs
				dataList.add(kw, .iconKeyword)
				
		else if preceedingText.endsWith(" as ") or preceedingText.endsWith(" = ")
			for kw in .keywordsCobraTypes
				dataList.add(kw, .iconKeyword)
			
			# return all types from explicit and implicit references TODO FASTER!!!
			dataList.addRange(_getTypesFromRefs)
		
		else if preceedingText.endsWith(" inherits ")
			#TODO: return class names
			pass
			
		else if preceedingText.endsWith(" implements ")
			#TODO: return interface names
			pass
			
		else if preceedingText.endsWith(" adds ")
			#TODO: return mixin names
			pass
			
		else if preceedingText.endsWith(" has ")
			#TODO: return attribute names
			pass
			
		else
			#TODO finer context
			for kw in .keywordsTopLevel
				dataList.add(kw, .iconKeyword)
		
		return dataList

	def _getCompletionData(region as DomRegion, preceedingText as String, currText as String,
							nodeMap as Dictionary<of DomRegion, ISyntaxNode>) as ICompletionDataList
		"""
		Returns completion data in the context of the given DomRegion.
		"""
		require
			.document.editor <> nil
			.document.editor.document <> nil
		body
			dataList = CompletionDataList()
			dataList.addRange(_getTopLevelCompletionData(preceedingText, currText))
			
			textDoc = .document.editor.document
			firstRegionLine = textDoc.getLineText(region.beginLine).trimStart
			
			if firstRegionLine.startsWith("namespace ")
				# being inside a namespace means we have access to all the classes inside of it
				dataList.addRange(_getNamespaceCompletionData(nodeMap[region] to NameSpace))
				
			else if firstRegionLine.startsWith("class ") and nodeMap[region] inherits Class
				/#
				Implicit class initializers would also fall into this block if we didn't check
				to make sure that the node inherits from 'Class.'
				#/
			
				# being inside a class gives us access to all its fields and methods
				for kw in .keywordsInBox
					dataList.add(kw, .iconKeyword)
				
				dataList.addRange(_getClassMemberCompletionData(nodeMap[region] to Class))
				
			else if firstRegionLine.startsWith("def ") or firstRegionLine.startsWith("get ") or firstRegionLine.startsWith("set ")
				# being inside a method gives us access to all its local variables and more Cobra keywords
				for kw in .keywordsInMethod
					dataList.add(kw, .iconKeyword)
				
				if firstRegionLine.startsWith("def ")
					dataList.addRange(_getMethodVarCompletionData(nodeMap[region] to AbstractMethod))
			
			return dataList

	def _getNamespacesFromProjectRefs as ICompletionDataList
		"""
		Returns the namespaces of the types in the current project references
		"""
		#TODO do it right with only one namespace level at as time
		nsList = List<of String>()
		
		proj = .document.project to DotNetProject
		for r in proj.references
			for asmFileName in r.getReferencedFileNames(DefaultConfigurationSelector())
				try
					asm = System.Reflection.Assembly.loadFile(asmFileName)
					if asm <> nil
						for t in asm.getTypes
							if t.namespace <> nil and t.namespace not in nsList
								nsList.add(t.namespace)
				catch ex as Exception
					# failed to load assembly, just ignore it for now
					trace ex.message
		
		dataList = CompletionDataList()
		
		for ns in nsList
			dataList.add(ns, .iconNamespace)
		
		return dataList
		
	def _getTypesFromRefs as ICompletionDataList
		"""
		Returns all types from the assemblies referenced by the project and
		implicitly referenced by Cobra.
		"""
		dataList = CompletionDataList()
		
		#TODO: memoize to improve performance
		
		# add types from explicit references
		proj = .document.project to DotNetProject
		for r in proj.references
			for asmFileName in r.getReferencedFileNames(DefaultConfigurationSelector())
				try
					asm = System.Reflection.Assembly.loadFile(asmFileName)
					if asm <> nil
						dataList.addRange(_getPublicTypesFromAssembly(asm))
							
				catch ex as Exception
					# failed to load assembly, just ignore it for now
					trace ex.message
					
		# add types from implicit references
		dataList.addRange(_getImplicitTypes)
		
		return dataList



	sig TypeFilter(t as Type) as bool is protected


	def _getPublicTypesFromAssembly(asm as System.Reflection.Assembly) as ICompletionDataList
		"""
		Given an assembly, return its public types in a completion list.
		"""
		/#
		TODO: Maybe not in this function, but somewhere...
		Filter out non-fully-qualified-type names if
		there is no use statement for their namespace.
		#/
		filter as TypeFilter = do(t as Type)
			return t.isPublic

		dataList = CompletionDataList()
		dataList.addRange(_typesToCompletionList(asm.getTypes, filter))
		return dataList


	def _typesToCompletionList(types as Type[]?, filter as TypeFilter) as ICompletionDataList
		"""
		Returns a completion data list containing the types in the given array for
		which the given filter method reference returns true.
		"""
		dataList = CompletionDataList()

		if types == nil
			return dataList

		for t in types to !

			if filter(t)

				fullName = t.fullName
				name = t.name

				if t.isGenericType
					#TODO: format to Cobra name
					name = t.name
					fullName = t.fullName

				if t.isClass
					dataList.add(name, .iconClass)
					dataList.add(fullName, .iconClass)
				else if t.isInterface
					dataList.add(name, .iconInterface)
					dataList.add(fullName, .iconInterface)
				else if t.isEnum
					dataList.add(name, .iconEnum)
					dataList.add(fullName, .iconEnum)
				else #TODO: the rest
					dataList.add(name, .iconEvent)
					dataList.add(fullName, .iconEvent)

		return dataList


	def _getImplicitTypes as ICompletionDataList
		"""
		Returns the public types made available by the implicit use directives.
		"""
		dataList = CompletionDataList()

		# include all public types from these namespaces
		implicitNamespaces = @[
			'System',
			'System.Collections.Generic',
			'System.IO',
			'System.Text',
		]

		filter as TypeFilter = do(t as Type)
			return t.isPublic and t.namespace in implicitNamespaces

		asm = System.Reflection.Assembly.load('mscorlib.dll')
		dataList.addRange(_typesToCompletionList(asm.getTypes, filter))

		# System.dll
		asm = System.Diagnostics.Process.getType.assembly
		dataList.addRange(_typesToCompletionList(asm.getTypes, filter))

		# include all public types from Cobra.Core.dll
		asm = Cobra.Core.CobraCore.getType.assembly
		dataList.addRange(_getPublicTypesFromAssembly(asm to !))

		return dataList

		
	def _getNamespaceCompletionData(n as NameSpace) as ICompletionDataList
		"""
		Given a namespace node, return the namespaces and types it provides.
		"""
		
		decls = CompletionDataList()
		
		for d in n.declsInOrder
			if d inherits Class
				decls.add(d.name, .iconClass)
			else if d inherits MethodSig
				decls.add(d.name, .iconDelegate)
			else if d inherits Struct
				decls.add(d.name, .iconStruct)
			else if d inherits Interface
				decls.add(d.name, .iconInterface)
			else if d inherits NameSpace
				decls.add(d.name, .iconNamespace)
			else if d inherits EnumDecl
				decls.add(d.name, .iconEnum)
		
		return decls
		
	def _getClassMemberCompletionData(c as Class) as ICompletionDataList
		"""
		Given a class node, return the members associated with it.
		"""
		
		decls = CompletionDataList()
		
		for d in c.declsInOrder
			if d inherits AbstractMethod
				decls.add(d.name, .iconMethod)
			else
				decls.add(d.name, .iconField)
				
		baseClass = c.baseClass
		while baseClass <> nil
			baseDecls = _getClassMemberCompletionData(baseClass to !)
			decls.addRange(baseDecls to CompletionDataList)
			baseClass = baseClass.baseClass
		
		return decls
		
	def _getMethodVarCompletionData(m as AbstractMethod) as ICompletionDataList
		"""
		Given a method node, return the local variables and parameters associated with it.
		"""
		
		vars = CompletionDataList()
		
		for v in m.locals
			vars.add(v.name, .iconField)
		
		vars.addRange(_getVarsFromStatements(m.statements))
		
		for p in m.params
			vars.add(p.name, .iconField)
		
		return vars
		
	def _getVarsFromForLoop(forLoop as ForStmt) as ICompletionDataList
		"""
		Returns the variables declared in the given for loop syntax node.
		"""
		vars = CompletionDataList()
		vars.add(forLoop.varExpr.name, .iconField)
		vars.addRange(_getVarsFromBlock(forLoop.block))
		return vars
		
	def _getVarsFromWhileLoop(whileLoop as AbstractWhileStmt) as ICompletionDataList
		"""
		Returns the variables declared in the given for loop syntax node.
		"""
		vars = CompletionDataList()
		vars.addRange(_getVarsFromBlock(whileLoop.block))
		return vars
		
	def _getVarsFromTryCatchBlock(tryCatchBlock as TryStmt) as ICompletionDataList
		"""
		Returns the variables declared in the given try-catch statement block.
		"""
		vars = CompletionDataList()
		
		vars.addRange(_getVarsFromBlock(tryCatchBlock.tryBlock))
		
		if tryCatchBlock.successBlock <> nil
			vars.addRange(_getVarsFromBlock(tryCatchBlock.successBlock to !))
		
		if tryCatchBlock.successBlock <> nil
			vars.addRange(_getVarsFromBlock(tryCatchBlock.finallyBlock to !))
			
		for catchBlock in tryCatchBlock.catchBlocks
			vars.addRange(_getVarsFromBlock(catchBlock.block))
		
		return vars
		
	def _getVarsFromBlock(block as BlockStmt) as ICompletionDataList
		"""
		Returns the variables declared in the given block of statements.
		"""
		return _getVarsFromStatements(block.stmts)
		
	def _getVarsFromStatements(stmts as List<of Stmt>) as ICompletionDataList
		"""
		Returns the variables declared in the given list of statements.
		"""
		vars = CompletionDataList()
		
		for s in stmts
			if s inherits AssignExpr
				if s.left inherits IdentifierExpr
					vars.add(_getVarFromAssignExpr(s), .iconField)
			else if s inherits ForStmt
				vars.addRange(_getVarsFromForLoop(s))
			else if s inherits AbstractWhileStmt
				vars.addRange(_getVarsFromWhileLoop(s))
			else if s inherits TryStmt
				vars.addRange(_getVarsFromTryCatchBlock(s))
			else if s inherits IfStmt
				vars.addRange(_getVarsFromBlock(s.trueStmts))
				if s.falseStmts <> nil
					vars.addRange(_getVarsFromBlock(s.falseStmts to !))
		
		return vars
	
		
	def _getVarFromAssignExpr(expr as AssignExpr) as String?
		"""
		Given an assignment expression, returns the identifier on the left hand side.
		"""
		if expr.left inherits IdentifierExpr
			return (expr.left to IdentifierExpr).name

		# the assignment is probably not declaring a variable (e.g. foo.bar = 1)
		return nil
